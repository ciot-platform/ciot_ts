// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "hg/proto/v1/hg_bridge.proto" (package "Hg", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Message representing an Modbus TAG Link
 *
 * @generated from protobuf message Hg.BridgeTagLinkMbus
 */
export interface BridgeTagLinkMbus {
    /**
     * @generated from protobuf field: uint32 address = 1
     */
    address: number; // Mbus reg address
}
/**
 * Message representing an TAG link
 *
 * @generated from protobuf message Hg.BridgeTagLink
 */
export interface BridgeTagLink {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "mbus";
        /**
         * @generated from protobuf field: Hg.BridgeTagLinkMbus mbus = 1
         */
        mbus: BridgeTagLinkMbus; // Mbus tag link configuration
    } | {
        oneofKind: undefined;
    };
}
/**
 * Message representing an Sensor information
 *
 * @generated from protobuf message Hg.BridgeSensor
 */
export interface BridgeSensor {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number; // TAG sensor id
    /**
     * @generated from protobuf field: uint32 serial = 2
     */
    serial: number; // TAG sensor serial number
    /**
     * @generated from protobuf field: bytes protocol_version = 3
     */
    protocolVersion: Uint8Array; // TAG sensor protocol version
    /**
     * @generated from protobuf field: bytes app_version = 4
     */
    appVersion: Uint8Array; // TAG sensor app version
    /**
     * @generated from protobuf field: bool online = 5
     */
    online: boolean; // TAG sensor communication status
}
/**
 * Message representing an TAG
 *
 * @generated from protobuf message Hg.BridgeTag
 */
export interface BridgeTag {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string; // TAG name
    /**
     * @generated from protobuf field: Hg.BridgeSensor sensor = 2
     */
    sensor?: BridgeSensor; // TAG sensor info
    /**
     * @generated from protobuf field: Hg.BridgeTagLink link = 3
     */
    link?: BridgeTagLink; // TAG link
    /**
     * @generated from protobuf field: float value = 4
     */
    value: number; // TAG value
    /**
     * @generated from protobuf field: Hg.BridgeDataType data_type = 5
     */
    dataType: BridgeDataType; // TAG data type
}
/**
 * Message representing an TAG list
 *
 * @generated from protobuf message Hg.BridgeTagList
 */
export interface BridgeTagList {
    /**
     * @generated from protobuf field: repeated Hg.BridgeTag items = 1
     */
    items: BridgeTag[]; // TAG list
}
/**
 * Message representing an request to edit TAG data
 *
 * @generated from protobuf message Hg.BridgeReqTagEdit
 */
export interface BridgeReqTagEdit {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number; // TAG list index (0 - 32)
    /**
     * @generated from protobuf field: Hg.BridgeTag tag = 2
     */
    tag?: BridgeTag; // TAG data
}
/**
 * Message representing an request to edir TAG list
 *
 * @generated from protobuf message Hg.BridgeReqListEdit
 */
export interface BridgeReqListEdit {
    /**
     * @generated from protobuf field: Hg.BridgeTagList list = 1
     */
    list?: BridgeTagList;
}
/**
 * @generated from protobuf message Hg.BridgeReqDeleteItem
 */
export interface BridgeReqDeleteItem {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message Hg.BridgeCfg
 */
export interface BridgeCfg {
    /**
     * @generated from protobuf field: bool rs485 = 1
     */
    rs485: boolean; // Enable rs485
    /**
     * @generated from protobuf field: bool mbus = 2
     */
    mbus: boolean; // Enable mbus protocol
}
/**
 * Message representing an Bridge request
 *
 * @generated from protobuf message Hg.BridgeReq
 */
export interface BridgeReq {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "getData";
        /**
         * @generated from protobuf field: Hg.BridgeGetData get_data = 1
         */
        getData: BridgeGetData; // Message to get data
    } | {
        oneofKind: "cfg";
        /**
         * @generated from protobuf field: Hg.BridgeCfg cfg = 2
         */
        cfg: BridgeCfg; // Message with hg bridge cfg
    } | {
        oneofKind: "getItem";
        /**
         * @generated from protobuf field: Hg.BridgeReqTagEdit get_item = 3
         */
        getItem: BridgeReqTagEdit; // Message to get item
    } | {
        oneofKind: "setItem";
        /**
         * @generated from protobuf field: Hg.BridgeReqTagEdit set_item = 4
         */
        setItem: BridgeReqTagEdit; // Message to set item
    } | {
        oneofKind: "deleteItem";
        /**
         * @generated from protobuf field: Hg.BridgeReqDeleteItem delete_item = 5
         */
        deleteItem: BridgeReqDeleteItem; // Message to delete item
    } | {
        oneofKind: undefined;
    };
}
/**
 * Enumeration of supported service data types
 *
 * @generated from protobuf enum Hg.BridgeDataType
 */
export enum BridgeDataType {
    /**
     * None
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_NONE = 0;
     */
    BRIDGE_DATA_TYPE_NONE = 0,
    /**
     * Temperature
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_TEMP = 1;
     */
    BRIDGE_DATA_TYPE_TEMP = 1,
    /**
     * RMS2 axis X
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_RMS2_X = 2;
     */
    BRIDGE_DATA_TYPE_RMS2_X = 2,
    /**
     * RMS2 axis y
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_RMS2_Y = 3;
     */
    BRIDGE_DATA_TYPE_RMS2_Y = 3,
    /**
     * RMS2 axis z
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_RMS2_Z = 4;
     */
    BRIDGE_DATA_TYPE_RMS2_Z = 4,
    /**
     * RMMS axis x
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_RMMS_X = 5;
     */
    BRIDGE_DATA_TYPE_RMMS_X = 5,
    /**
     * RMMS axis y
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_RMMS_Y = 6;
     */
    BRIDGE_DATA_TYPE_RMMS_Y = 6,
    /**
     * RMMS axis z
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_RMMS_Z = 7;
     */
    BRIDGE_DATA_TYPE_RMMS_Z = 7,
    /**
     * Tilt roll
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_TILT_ROLL = 8;
     */
    BRIDGE_DATA_TYPE_TILT_ROLL = 8,
    /**
     * Tilt pitch
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_TILT_PITCH = 9;
     */
    BRIDGE_DATA_TYPE_TILT_PITCH = 9,
    /**
     * NTC channel A
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_NTC_A = 10;
     */
    BRIDGE_DATA_TYPE_NTC_A = 10,
    /**
     * NTC channel B
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_NTC_B = 11;
     */
    BRIDGE_DATA_TYPE_NTC_B = 11,
    /**
     * 4T20 channel A
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_4T20_A = 12;
     */
    BRIDGE_DATA_TYPE_4T20_A = 12,
    /**
     * 4T20 channel B
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_4T20_B = 13;
     */
    BRIDGE_DATA_TYPE_4T20_B = 13,
    /**
     * POT channel A
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_POT_A = 14;
     */
    BRIDGE_DATA_TYPE_POT_A = 14,
    /**
     * POT channel B
     *
     * @generated from protobuf enum value: BRIDGE_DATA_TYPE_POT_B = 15;
     */
    BRIDGE_DATA_TYPE_POT_B = 15
}
/**
 * @generated from protobuf enum Hg.BridgeGetData
 */
export enum BridgeGetData {
    /**
     * @generated from protobuf enum value: BRIDGE_GET_DATA_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: BRIDGE_GET_DATA_CFG = 1;
     */
    CFG = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class BridgeTagLinkMbus$Type extends MessageType<BridgeTagLinkMbus> {
    constructor() {
        super("Hg.BridgeTagLinkMbus", [
            { no: 1, name: "address", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BridgeTagLinkMbus>): BridgeTagLinkMbus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = 0;
        if (value !== undefined)
            reflectionMergePartial<BridgeTagLinkMbus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeTagLinkMbus): BridgeTagLinkMbus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 address */ 1:
                    message.address = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeTagLinkMbus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 address = 1; */
        if (message.address !== 0)
            writer.tag(1, WireType.Varint).uint32(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeTagLinkMbus
 */
export const BridgeTagLinkMbus = new BridgeTagLinkMbus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeTagLink$Type extends MessageType<BridgeTagLink> {
    constructor() {
        super("Hg.BridgeTagLink", [
            { no: 1, name: "mbus", kind: "message", oneof: "type", T: () => BridgeTagLinkMbus }
        ]);
    }
    create(value?: PartialMessage<BridgeTagLink>): BridgeTagLink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<BridgeTagLink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeTagLink): BridgeTagLink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Hg.BridgeTagLinkMbus mbus */ 1:
                    message.type = {
                        oneofKind: "mbus",
                        mbus: BridgeTagLinkMbus.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).mbus)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeTagLink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Hg.BridgeTagLinkMbus mbus = 1; */
        if (message.type.oneofKind === "mbus")
            BridgeTagLinkMbus.internalBinaryWrite(message.type.mbus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeTagLink
 */
export const BridgeTagLink = new BridgeTagLink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeSensor$Type extends MessageType<BridgeSensor> {
    constructor() {
        super("Hg.BridgeSensor", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "serial", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "protocol_version", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "app_version", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "online", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BridgeSensor>): BridgeSensor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.serial = 0;
        message.protocolVersion = new Uint8Array(0);
        message.appVersion = new Uint8Array(0);
        message.online = false;
        if (value !== undefined)
            reflectionMergePartial<BridgeSensor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeSensor): BridgeSensor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 serial */ 2:
                    message.serial = reader.uint32();
                    break;
                case /* bytes protocol_version */ 3:
                    message.protocolVersion = reader.bytes();
                    break;
                case /* bytes app_version */ 4:
                    message.appVersion = reader.bytes();
                    break;
                case /* bool online */ 5:
                    message.online = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeSensor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 serial = 2; */
        if (message.serial !== 0)
            writer.tag(2, WireType.Varint).uint32(message.serial);
        /* bytes protocol_version = 3; */
        if (message.protocolVersion.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.protocolVersion);
        /* bytes app_version = 4; */
        if (message.appVersion.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.appVersion);
        /* bool online = 5; */
        if (message.online !== false)
            writer.tag(5, WireType.Varint).bool(message.online);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeSensor
 */
export const BridgeSensor = new BridgeSensor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeTag$Type extends MessageType<BridgeTag> {
    constructor() {
        super("Hg.BridgeTag", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sensor", kind: "message", T: () => BridgeSensor },
            { no: 3, name: "link", kind: "message", T: () => BridgeTagLink },
            { no: 4, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "data_type", kind: "enum", T: () => ["Hg.BridgeDataType", BridgeDataType] }
        ]);
    }
    create(value?: PartialMessage<BridgeTag>): BridgeTag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = 0;
        message.dataType = 0;
        if (value !== undefined)
            reflectionMergePartial<BridgeTag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeTag): BridgeTag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* Hg.BridgeSensor sensor */ 2:
                    message.sensor = BridgeSensor.internalBinaryRead(reader, reader.uint32(), options, message.sensor);
                    break;
                case /* Hg.BridgeTagLink link */ 3:
                    message.link = BridgeTagLink.internalBinaryRead(reader, reader.uint32(), options, message.link);
                    break;
                case /* float value */ 4:
                    message.value = reader.float();
                    break;
                case /* Hg.BridgeDataType data_type */ 5:
                    message.dataType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeTag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* Hg.BridgeSensor sensor = 2; */
        if (message.sensor)
            BridgeSensor.internalBinaryWrite(message.sensor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Hg.BridgeTagLink link = 3; */
        if (message.link)
            BridgeTagLink.internalBinaryWrite(message.link, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* float value = 4; */
        if (message.value !== 0)
            writer.tag(4, WireType.Bit32).float(message.value);
        /* Hg.BridgeDataType data_type = 5; */
        if (message.dataType !== 0)
            writer.tag(5, WireType.Varint).int32(message.dataType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeTag
 */
export const BridgeTag = new BridgeTag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeTagList$Type extends MessageType<BridgeTagList> {
    constructor() {
        super("Hg.BridgeTagList", [
            { no: 1, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BridgeTag }
        ]);
    }
    create(value?: PartialMessage<BridgeTagList>): BridgeTagList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<BridgeTagList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeTagList): BridgeTagList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Hg.BridgeTag items */ 1:
                    message.items.push(BridgeTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeTagList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Hg.BridgeTag items = 1; */
        for (let i = 0; i < message.items.length; i++)
            BridgeTag.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeTagList
 */
export const BridgeTagList = new BridgeTagList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeReqTagEdit$Type extends MessageType<BridgeReqTagEdit> {
    constructor() {
        super("Hg.BridgeReqTagEdit", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tag", kind: "message", T: () => BridgeTag }
        ]);
    }
    create(value?: PartialMessage<BridgeReqTagEdit>): BridgeReqTagEdit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<BridgeReqTagEdit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeReqTagEdit): BridgeReqTagEdit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* Hg.BridgeTag tag */ 2:
                    message.tag = BridgeTag.internalBinaryRead(reader, reader.uint32(), options, message.tag);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeReqTagEdit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* Hg.BridgeTag tag = 2; */
        if (message.tag)
            BridgeTag.internalBinaryWrite(message.tag, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeReqTagEdit
 */
export const BridgeReqTagEdit = new BridgeReqTagEdit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeReqListEdit$Type extends MessageType<BridgeReqListEdit> {
    constructor() {
        super("Hg.BridgeReqListEdit", [
            { no: 1, name: "list", kind: "message", T: () => BridgeTagList }
        ]);
    }
    create(value?: PartialMessage<BridgeReqListEdit>): BridgeReqListEdit {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BridgeReqListEdit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeReqListEdit): BridgeReqListEdit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Hg.BridgeTagList list */ 1:
                    message.list = BridgeTagList.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeReqListEdit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Hg.BridgeTagList list = 1; */
        if (message.list)
            BridgeTagList.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeReqListEdit
 */
export const BridgeReqListEdit = new BridgeReqListEdit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeReqDeleteItem$Type extends MessageType<BridgeReqDeleteItem> {
    constructor() {
        super("Hg.BridgeReqDeleteItem", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BridgeReqDeleteItem>): BridgeReqDeleteItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<BridgeReqDeleteItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeReqDeleteItem): BridgeReqDeleteItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeReqDeleteItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeReqDeleteItem
 */
export const BridgeReqDeleteItem = new BridgeReqDeleteItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeCfg$Type extends MessageType<BridgeCfg> {
    constructor() {
        super("Hg.BridgeCfg", [
            { no: 1, name: "rs485", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "mbus", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BridgeCfg>): BridgeCfg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rs485 = false;
        message.mbus = false;
        if (value !== undefined)
            reflectionMergePartial<BridgeCfg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeCfg): BridgeCfg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool rs485 */ 1:
                    message.rs485 = reader.bool();
                    break;
                case /* bool mbus */ 2:
                    message.mbus = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeCfg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool rs485 = 1; */
        if (message.rs485 !== false)
            writer.tag(1, WireType.Varint).bool(message.rs485);
        /* bool mbus = 2; */
        if (message.mbus !== false)
            writer.tag(2, WireType.Varint).bool(message.mbus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeCfg
 */
export const BridgeCfg = new BridgeCfg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BridgeReq$Type extends MessageType<BridgeReq> {
    constructor() {
        super("Hg.BridgeReq", [
            { no: 1, name: "get_data", kind: "enum", oneof: "type", T: () => ["Hg.BridgeGetData", BridgeGetData, "BRIDGE_GET_DATA_"] },
            { no: 2, name: "cfg", kind: "message", oneof: "type", T: () => BridgeCfg },
            { no: 3, name: "get_item", kind: "message", oneof: "type", T: () => BridgeReqTagEdit },
            { no: 4, name: "set_item", kind: "message", oneof: "type", T: () => BridgeReqTagEdit },
            { no: 5, name: "delete_item", kind: "message", oneof: "type", T: () => BridgeReqDeleteItem }
        ]);
    }
    create(value?: PartialMessage<BridgeReq>): BridgeReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<BridgeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BridgeReq): BridgeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Hg.BridgeGetData get_data */ 1:
                    message.type = {
                        oneofKind: "getData",
                        getData: reader.int32()
                    };
                    break;
                case /* Hg.BridgeCfg cfg */ 2:
                    message.type = {
                        oneofKind: "cfg",
                        cfg: BridgeCfg.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).cfg)
                    };
                    break;
                case /* Hg.BridgeReqTagEdit get_item */ 3:
                    message.type = {
                        oneofKind: "getItem",
                        getItem: BridgeReqTagEdit.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).getItem)
                    };
                    break;
                case /* Hg.BridgeReqTagEdit set_item */ 4:
                    message.type = {
                        oneofKind: "setItem",
                        setItem: BridgeReqTagEdit.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).setItem)
                    };
                    break;
                case /* Hg.BridgeReqDeleteItem delete_item */ 5:
                    message.type = {
                        oneofKind: "deleteItem",
                        deleteItem: BridgeReqDeleteItem.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).deleteItem)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BridgeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Hg.BridgeGetData get_data = 1; */
        if (message.type.oneofKind === "getData")
            writer.tag(1, WireType.Varint).int32(message.type.getData);
        /* Hg.BridgeCfg cfg = 2; */
        if (message.type.oneofKind === "cfg")
            BridgeCfg.internalBinaryWrite(message.type.cfg, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Hg.BridgeReqTagEdit get_item = 3; */
        if (message.type.oneofKind === "getItem")
            BridgeReqTagEdit.internalBinaryWrite(message.type.getItem, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Hg.BridgeReqTagEdit set_item = 4; */
        if (message.type.oneofKind === "setItem")
            BridgeReqTagEdit.internalBinaryWrite(message.type.setItem, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* Hg.BridgeReqDeleteItem delete_item = 5; */
        if (message.type.oneofKind === "deleteItem")
            BridgeReqDeleteItem.internalBinaryWrite(message.type.deleteItem, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BridgeReq
 */
export const BridgeReq = new BridgeReq$Type();
