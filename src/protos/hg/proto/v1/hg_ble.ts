// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "hg/proto/v1/hg_ble.proto" (package "Hg", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Status as Status$ } from "../../../pcm/proto/v1/pcm";
import { BleScnStatus } from "../../../ciot/proto/v2/ble_scn";
import { BleAdvStatus } from "../../../ciot/proto/v2/ble_adv";
import { BleStatus } from "../../../ciot/proto/v2/ble";
import { UsbStatus } from "../../../ciot/proto/v2/usb";
import { UartStatus } from "../../../ciot/proto/v2/uart";
import { SysStatus } from "../../../ciot/proto/v2/sys";
import { Status } from "../../../ciot/proto/v2/ciot";
import { BleInfo as BleInfo$ } from "../../../ciot/proto/v2/ble";
import { SysInfo } from "../../../ciot/proto/v2/sys";
/**
 * HG BLE Module adv data message
 *
 * @generated from protobuf message Hg.BleAdv
 */
export interface BleAdv {
    /**
     * @generated from protobuf field: uint64 t = 1
     */
    t: bigint; // Timestamp
    /**
     * @generated from protobuf field: optional bytes mac = 2
     */
    mac?: Uint8Array; // Sensor MAC address
    /**
     * @generated from protobuf field: sint32 rssi = 3
     */
    rssi: number; // Sensor RSSI
    /**
     * @generated from protobuf field: bytes payload = 4
     */
    payload: Uint8Array; // Sensor adv payload
}
/**
 * HG BLE Module information data
 *
 * @generated from protobuf message Hg.BleInfo
 */
export interface BleInfo {
    /**
     * @generated from protobuf field: uint32 sn = 1
     */
    sn: number; // Device serial number
    /**
     * @generated from protobuf field: Ciot.SysInfo sys = 2
     */
    sys?: SysInfo; // System information
    /**
     * @generated from protobuf field: Ciot.BleInfo ble = 3
     */
    ble?: BleInfo$; // Bluetooth information
}
/**
 * HG BLE Module health message
 *
 * @generated from protobuf message Hg.BleHealth
 */
export interface BleHealth {
    /**
     * @generated from protobuf field: uint64 t = 1
     */
    t: bigint; // Message timestamp
    /**
     * @generated from protobuf field: Hg.BleState state = 2
     */
    state: BleState; // Gateway state
    /**
     * @generated from protobuf field: Hg.BleInfo info = 3
     */
    info?: BleInfo; // Gateway bluetooth module information
    /**
     * @generated from protobuf field: Ciot.Status ciot = 4
     */
    ciot?: Status; // CIoT status
    /**
     * @generated from protobuf field: Ciot.SysStatus sys = 5
     */
    sys?: SysStatus; // System status
    /**
     * @generated from protobuf field: Ciot.UartStatus uart = 6
     */
    uart?: UartStatus; // UART status
    /**
     * @generated from protobuf field: Ciot.UsbStatus usb = 7
     */
    usb?: UsbStatus; // USB status
    /**
     * @generated from protobuf field: Ciot.BleStatus ble = 8
     */
    ble?: BleStatus; // Bluetooth status
    /**
     * @generated from protobuf field: Ciot.BleAdvStatus ble_adv = 9
     */
    bleAdv?: BleAdvStatus; // Bluetooth advertisement interface status
    /**
     * @generated from protobuf field: Ciot.BleScnStatus ble_scn = 10
     */
    bleScn?: BleScnStatus; // Bluetooth scanning interface status
    /**
     * @generated from protobuf field: Pcm.Status pcm = 11
     */
    pcm?: Status$; // Pcm module status
}
/**
 * HG BLE Module interfaces ids
 *
 * @generated from protobuf enum Hg.BleIfaceId
 */
export enum BleIfaceId {
    /**
     * CIoT interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_CIOT = 0;
     */
    CIOT = 0,
    /**
     * System interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_SYS = 1;
     */
    SYS = 1,
    /**
     * UART interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_UART = 2;
     */
    UART = 2,
    /**
     * USB interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_USB = 3;
     */
    USB = 3,
    /**
     * Bluetooth interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_BLE = 4;
     */
    BLE = 4,
    /**
     * Ble advertisement interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_BLE_ADV = 5;
     */
    BLE_ADV = 5,
    /**
     * Ble scanner interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_BLE_SCN = 6;
     */
    BLE_SCN = 6,
    /**
     * CIoT interfaces count
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_COUNT = 7;
     */
    COUNT = 7,
    /**
     * Gateway BLE scanner interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_HG_BLE = 13;
     */
    HG_BLE = 13,
    /**
     * Gateway TCP interface
     *
     * @generated from protobuf enum value: BLE_IFACE_ID_HG_TCP = 14;
     */
    HG_TCP = 14
}
/**
 * HG BLE Module states
 *
 * @generated from protobuf enum Hg.BleState
 */
export enum BleState {
    /**
     * Idle
     *
     * @generated from protobuf enum value: BLE_STATE_IDLE = 0;
     */
    IDLE = 0,
    /**
     * Ble scanner started
     *
     * @generated from protobuf enum value: BLE_STATE_STARTED = 1;
     */
    STARTED = 1,
    /**
     * Ble scanner provisioned
     *
     * @generated from protobuf enum value: BLE_STATE_PROVISIONED = 2;
     */
    PROVISIONED = 2
}
/**
 * HG BLE Module message types
 *
 * @generated from protobuf enum Hg.BleMsgType
 */
export enum BleMsgType {
    /**
     * Ack message
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_ACK = 0;
     */
    ACK = 0,
    /**
     * Prov available message
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_PROV_AVAILABLE = 1;
     */
    PROV_AVAILABLE = 1,
    /**
     * Configuration available message
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_CFG_AVAILABLE = 2;
     */
    CFG_AVAILABLE = 2,
    /**
     * Single packet data message
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_SINGLE_PKT_DATA = 3;
     */
    SINGLE_PKT_DATA = 3,
    /**
     * Multiple packet data message
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_MULTI_PKT_DATA = 4;
     */
    MULTI_PKT_DATA = 4,
    /**
     * Povisioning request
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_PROV_REQ = 5;
     */
    PROV_REQ = 5,
    /**
     * Configuration request
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_CFG_REQ = 6;
     */
    CFG_REQ = 6,
    /**
     * Data missing recovery request
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_DATA_MISSING_REQ = 7;
     */
    DATA_MISSING_REQ = 7,
    /**
     * Reset request
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_RST_REQ = 8;
     */
    RST_REQ = 8,
    /**
     * DFU available message
     *
     * @generated from protobuf enum value: BLE_MSG_TYPE_DFU_AVAILABLE = 9;
     */
    DFU_AVAILABLE = 9
}
// @generated message type with reflection information, may provide speed optimized methods
class BleAdv$Type extends MessageType<BleAdv> {
    constructor() {
        super("Hg.BleAdv", [
            { no: 1, name: "t", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "mac", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "rssi", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BleAdv>): BleAdv {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = 0n;
        message.rssi = 0;
        message.payload = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<BleAdv>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BleAdv): BleAdv {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 t */ 1:
                    message.t = reader.uint64().toBigInt();
                    break;
                case /* optional bytes mac */ 2:
                    message.mac = reader.bytes();
                    break;
                case /* sint32 rssi */ 3:
                    message.rssi = reader.sint32();
                    break;
                case /* bytes payload */ 4:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BleAdv, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 t = 1; */
        if (message.t !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.t);
        /* optional bytes mac = 2; */
        if (message.mac !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.mac);
        /* sint32 rssi = 3; */
        if (message.rssi !== 0)
            writer.tag(3, WireType.Varint).sint32(message.rssi);
        /* bytes payload = 4; */
        if (message.payload.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BleAdv
 */
export const BleAdv = new BleAdv$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BleInfo$Type extends MessageType<BleInfo> {
    constructor() {
        super("Hg.BleInfo", [
            { no: 1, name: "sn", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "sys", kind: "message", T: () => SysInfo },
            { no: 3, name: "ble", kind: "message", T: () => BleInfo$ }
        ]);
    }
    create(value?: PartialMessage<BleInfo>): BleInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sn = 0;
        if (value !== undefined)
            reflectionMergePartial<BleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BleInfo): BleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 sn */ 1:
                    message.sn = reader.uint32();
                    break;
                case /* Ciot.SysInfo sys */ 2:
                    message.sys = SysInfo.internalBinaryRead(reader, reader.uint32(), options, message.sys);
                    break;
                case /* Ciot.BleInfo ble */ 3:
                    message.ble = BleInfo$.internalBinaryRead(reader, reader.uint32(), options, message.ble);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 sn = 1; */
        if (message.sn !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sn);
        /* Ciot.SysInfo sys = 2; */
        if (message.sys)
            SysInfo.internalBinaryWrite(message.sys, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.BleInfo ble = 3; */
        if (message.ble)
            BleInfo$.internalBinaryWrite(message.ble, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BleInfo
 */
export const BleInfo = new BleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BleHealth$Type extends MessageType<BleHealth> {
    constructor() {
        super("Hg.BleHealth", [
            { no: 1, name: "t", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["Hg.BleState", BleState, "BLE_STATE_"] },
            { no: 3, name: "info", kind: "message", T: () => BleInfo },
            { no: 4, name: "ciot", kind: "message", T: () => Status },
            { no: 5, name: "sys", kind: "message", T: () => SysStatus },
            { no: 6, name: "uart", kind: "message", T: () => UartStatus },
            { no: 7, name: "usb", kind: "message", T: () => UsbStatus },
            { no: 8, name: "ble", kind: "message", T: () => BleStatus },
            { no: 9, name: "ble_adv", kind: "message", T: () => BleAdvStatus },
            { no: 10, name: "ble_scn", kind: "message", T: () => BleScnStatus },
            { no: 11, name: "pcm", kind: "message", T: () => Status$ }
        ]);
    }
    create(value?: PartialMessage<BleHealth>): BleHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = 0n;
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<BleHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BleHealth): BleHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 t */ 1:
                    message.t = reader.uint64().toBigInt();
                    break;
                case /* Hg.BleState state */ 2:
                    message.state = reader.int32();
                    break;
                case /* Hg.BleInfo info */ 3:
                    message.info = BleInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* Ciot.Status ciot */ 4:
                    message.ciot = Status.internalBinaryRead(reader, reader.uint32(), options, message.ciot);
                    break;
                case /* Ciot.SysStatus sys */ 5:
                    message.sys = SysStatus.internalBinaryRead(reader, reader.uint32(), options, message.sys);
                    break;
                case /* Ciot.UartStatus uart */ 6:
                    message.uart = UartStatus.internalBinaryRead(reader, reader.uint32(), options, message.uart);
                    break;
                case /* Ciot.UsbStatus usb */ 7:
                    message.usb = UsbStatus.internalBinaryRead(reader, reader.uint32(), options, message.usb);
                    break;
                case /* Ciot.BleStatus ble */ 8:
                    message.ble = BleStatus.internalBinaryRead(reader, reader.uint32(), options, message.ble);
                    break;
                case /* Ciot.BleAdvStatus ble_adv */ 9:
                    message.bleAdv = BleAdvStatus.internalBinaryRead(reader, reader.uint32(), options, message.bleAdv);
                    break;
                case /* Ciot.BleScnStatus ble_scn */ 10:
                    message.bleScn = BleScnStatus.internalBinaryRead(reader, reader.uint32(), options, message.bleScn);
                    break;
                case /* Pcm.Status pcm */ 11:
                    message.pcm = Status$.internalBinaryRead(reader, reader.uint32(), options, message.pcm);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BleHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 t = 1; */
        if (message.t !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.t);
        /* Hg.BleState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        /* Hg.BleInfo info = 3; */
        if (message.info)
            BleInfo.internalBinaryWrite(message.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.Status ciot = 4; */
        if (message.ciot)
            Status.internalBinaryWrite(message.ciot, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.SysStatus sys = 5; */
        if (message.sys)
            SysStatus.internalBinaryWrite(message.sys, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.UartStatus uart = 6; */
        if (message.uart)
            UartStatus.internalBinaryWrite(message.uart, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.UsbStatus usb = 7; */
        if (message.usb)
            UsbStatus.internalBinaryWrite(message.usb, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.BleStatus ble = 8; */
        if (message.ble)
            BleStatus.internalBinaryWrite(message.ble, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.BleAdvStatus ble_adv = 9; */
        if (message.bleAdv)
            BleAdvStatus.internalBinaryWrite(message.bleAdv, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.BleScnStatus ble_scn = 10; */
        if (message.bleScn)
            BleScnStatus.internalBinaryWrite(message.bleScn, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* Pcm.Status pcm = 11; */
        if (message.pcm)
            Status$.internalBinaryWrite(message.pcm, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.BleHealth
 */
export const BleHealth = new BleHealth$Type();
