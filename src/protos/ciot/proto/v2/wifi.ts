// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "ciot/proto/v2/wifi.proto" (package "Ciot", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TcpInfo } from "./tcp";
import { TcpStatus } from "./tcp";
import { TcpCfg } from "./tcp";
/**
 * Message representing information about a Wi-Fi access point.
 *
 * @generated from protobuf message Ciot.WifiApInfo
 */
export interface WifiApInfo {
    /**
     * @generated from protobuf field: bytes bssid = 1
     */
    bssid: Uint8Array; // BSSID (MAC address) of the access point.
    /**
     * @generated from protobuf field: string ssid = 2
     */
    ssid: string; // SSID (network name) of the access point.
    /**
     * @generated from protobuf field: int32 rssi = 3
     */
    rssi: number; // Received Signal Strength Indicator (RSSI) of the access point.
    /**
     * @generated from protobuf field: int32 authmode = 4
     */
    authmode: number; // Authentication mode of the access point.
}
/**
 * Stop Wi-Fi interface.
 *
 * @generated from protobuf message Ciot.WifiStop
 */
export interface WifiStop {
}
/**
 * Message representing configuration for the Wi-Fi interface.
 *
 * @generated from protobuf message Ciot.WifiCfg
 */
export interface WifiCfg {
    /**
     * @generated from protobuf field: bool disabled = 1
     */
    disabled: boolean; // Disable Wi-Fi interface
    /**
     * @generated from protobuf field: string ssid = 2
     */
    ssid: string; // SSID of the Wi-Fi network.
    /**
     * @generated from protobuf field: string password = 3
     */
    password: string; // Password for the Wi-Fi network.
    /**
     * @generated from protobuf field: Ciot.WifiType type = 4
     */
    type: WifiType; // Type of Wi-Fi connection.
    /**
     * @generated from protobuf field: Ciot.TcpCfg tcp = 5
     */
    tcp?: TcpCfg; // TCP configuration for Wi-Fi communication.
}
/**
 * Message representing status for the Wi-Fi interface.
 *
 * @generated from protobuf message Ciot.WifiStatus
 */
export interface WifiStatus {
    /**
     * @generated from protobuf field: uint32 disconnect_reason = 1
     */
    disconnectReason: number; // Reason for Wi-Fi disconnection.
    /**
     * @generated from protobuf field: Ciot.TcpStatus tcp = 2
     */
    tcp?: TcpStatus; // Status of the TCP connection over Wi-Fi.
    /**
     * @generated from protobuf field: Ciot.WifiScanState scan_state = 3
     */
    scanState: WifiScanState; // Wi-Fi scan state
}
/**
 * @generated from protobuf message Ciot.WifiInfo
 */
export interface WifiInfo {
    /**
     * @generated from protobuf field: Ciot.TcpInfo tcp = 1
     */
    tcp?: TcpInfo;
    /**
     * @generated from protobuf field: Ciot.WifiApInfo ap = 2
     */
    ap?: WifiApInfo;
}
/**
 * Message representing scan request
 *
 * @generated from protobuf message Ciot.WifiReqScan
 */
export interface WifiReqScan {
}
/**
 * Wifi scan result
 *
 * @generated from protobuf message Ciot.WifiReqScanResult
 */
export interface WifiReqScanResult {
    /**
     * @generated from protobuf field: uint32 count = 1
     */
    count: number; // Access point count found by scan request
}
/**
 * Wifi request to get the scanned access point information
 *
 * @generated from protobuf message Ciot.WifiReqGetAp
 */
export interface WifiReqGetAp {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number; // Access point ID
}
/**
 * Message representing a Wi-Fi request.
 *
 * @generated from protobuf message Ciot.WifiReq
 */
export interface WifiReq {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "scan";
        /**
         * @generated from protobuf field: Ciot.WifiReqScan scan = 1
         */
        scan: WifiReqScan; // Start wifi scanner
    } | {
        oneofKind: "getAp";
        /**
         * @generated from protobuf field: Ciot.WifiReqGetAp get_ap = 2
         */
        getAp: WifiReqGetAp; // Get acess point information from wifi scanner queue
    } | {
        oneofKind: undefined;
    };
}
/**
 * Message representing a Wi-Fi response.
 *
 * @generated from protobuf message Ciot.WifiResp
 */
export interface WifiResp {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "scan";
        /**
         * @generated from protobuf field: Ciot.WifiReqScanResult scan = 1
         */
        scan: WifiReqScanResult; // Wifi scanner result
    } | {
        oneofKind: "getAp";
        /**
         * @generated from protobuf field: Ciot.WifiApInfo get_ap = 2
         */
        getAp: WifiApInfo; // Get acess point result
    } | {
        oneofKind: undefined;
    };
}
/**
 * Message representing data for the Wi-Fi interface.
 *
 * @generated from protobuf message Ciot.WifiData
 */
export interface WifiData {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "stop";
        /**
         * @generated from protobuf field: Ciot.WifiStop stop = 1
         */
        stop: WifiStop; // Stop Wi-Fi interface.
    } | {
        oneofKind: "config";
        /**
         * @generated from protobuf field: Ciot.WifiCfg config = 2
         */
        config: WifiCfg; // Configuration for the Wi-Fi interface.
    } | {
        oneofKind: "status";
        /**
         * @generated from protobuf field: Ciot.WifiStatus status = 3
         */
        status: WifiStatus; // Status of the Wi-Fi interface.
    } | {
        oneofKind: "request";
        /**
         * @generated from protobuf field: Ciot.WifiReq request = 4
         */
        request: WifiReq; // Wi-Fi request data.
    } | {
        oneofKind: "response";
        /**
         * @generated from protobuf field: Ciot.WifiResp response = 5
         */
        response: WifiResp; // Wi-Fi response data.
    } | {
        oneofKind: "info";
        /**
         * @generated from protobuf field: Ciot.WifiInfo info = 6
         */
        info: WifiInfo; // TCP information.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Enum representing the type of Wi-Fi connection.
 *
 * @generated from protobuf enum Ciot.WifiType
 */
export enum WifiType {
    /**
     * Wi-Fi station mode.
     *
     * @generated from protobuf enum value: WIFI_TYPE_STA = 0;
     */
    STA = 0,
    /**
     * Wi-Fi access point mode.
     *
     * @generated from protobuf enum value: WIFI_TYPE_AP = 1;
     */
    AP = 1
}
/**
 * Enum representing the state of Wi-Fi scanning.
 *
 * @generated from protobuf enum Ciot.WifiScanState
 */
export enum WifiScanState {
    /**
     * Wi-Fi scan is idle.
     *
     * @generated from protobuf enum value: WIFI_SCAN_STATE_IDLE = 0;
     */
    IDLE = 0,
    /**
     * Wi-Fi scan is in progress.
     *
     * @generated from protobuf enum value: WIFI_SCAN_STATE_SCANNING = 1;
     */
    SCANNING = 1,
    /**
     * Wi-Fi scan completed successfully.
     *
     * @generated from protobuf enum value: WIFI_SCAN_STATE_SCANNED = 2;
     */
    SCANNED = 2,
    /**
     * Error occurred during Wi-Fi scan.
     *
     * @generated from protobuf enum value: WIFI_SCAN_STATE_ERROR = 3;
     */
    ERROR = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class WifiApInfo$Type extends MessageType<WifiApInfo> {
    constructor() {
        super("Ciot.WifiApInfo", [
            { no: 1, name: "bssid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "ssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "rssi", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "authmode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WifiApInfo>): WifiApInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bssid = new Uint8Array(0);
        message.ssid = "";
        message.rssi = 0;
        message.authmode = 0;
        if (value !== undefined)
            reflectionMergePartial<WifiApInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiApInfo): WifiApInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes bssid */ 1:
                    message.bssid = reader.bytes();
                    break;
                case /* string ssid */ 2:
                    message.ssid = reader.string();
                    break;
                case /* int32 rssi */ 3:
                    message.rssi = reader.int32();
                    break;
                case /* int32 authmode */ 4:
                    message.authmode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiApInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes bssid = 1; */
        if (message.bssid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.bssid);
        /* string ssid = 2; */
        if (message.ssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ssid);
        /* int32 rssi = 3; */
        if (message.rssi !== 0)
            writer.tag(3, WireType.Varint).int32(message.rssi);
        /* int32 authmode = 4; */
        if (message.authmode !== 0)
            writer.tag(4, WireType.Varint).int32(message.authmode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiApInfo
 */
export const WifiApInfo = new WifiApInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiStop$Type extends MessageType<WifiStop> {
    constructor() {
        super("Ciot.WifiStop", []);
    }
    create(value?: PartialMessage<WifiStop>): WifiStop {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WifiStop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiStop): WifiStop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiStop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiStop
 */
export const WifiStop = new WifiStop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiCfg$Type extends MessageType<WifiCfg> {
    constructor() {
        super("Ciot.WifiCfg", [
            { no: 1, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "ssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type", kind: "enum", T: () => ["Ciot.WifiType", WifiType, "WIFI_TYPE_"] },
            { no: 5, name: "tcp", kind: "message", T: () => TcpCfg }
        ]);
    }
    create(value?: PartialMessage<WifiCfg>): WifiCfg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.disabled = false;
        message.ssid = "";
        message.password = "";
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<WifiCfg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiCfg): WifiCfg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool disabled */ 1:
                    message.disabled = reader.bool();
                    break;
                case /* string ssid */ 2:
                    message.ssid = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                case /* Ciot.WifiType type */ 4:
                    message.type = reader.int32();
                    break;
                case /* Ciot.TcpCfg tcp */ 5:
                    message.tcp = TcpCfg.internalBinaryRead(reader, reader.uint32(), options, message.tcp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiCfg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool disabled = 1; */
        if (message.disabled !== false)
            writer.tag(1, WireType.Varint).bool(message.disabled);
        /* string ssid = 2; */
        if (message.ssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ssid);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        /* Ciot.WifiType type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* Ciot.TcpCfg tcp = 5; */
        if (message.tcp)
            TcpCfg.internalBinaryWrite(message.tcp, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiCfg
 */
export const WifiCfg = new WifiCfg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiStatus$Type extends MessageType<WifiStatus> {
    constructor() {
        super("Ciot.WifiStatus", [
            { no: 1, name: "disconnect_reason", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tcp", kind: "message", T: () => TcpStatus },
            { no: 3, name: "scan_state", kind: "enum", T: () => ["Ciot.WifiScanState", WifiScanState, "WIFI_SCAN_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<WifiStatus>): WifiStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.disconnectReason = 0;
        message.scanState = 0;
        if (value !== undefined)
            reflectionMergePartial<WifiStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiStatus): WifiStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 disconnect_reason */ 1:
                    message.disconnectReason = reader.uint32();
                    break;
                case /* Ciot.TcpStatus tcp */ 2:
                    message.tcp = TcpStatus.internalBinaryRead(reader, reader.uint32(), options, message.tcp);
                    break;
                case /* Ciot.WifiScanState scan_state */ 3:
                    message.scanState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 disconnect_reason = 1; */
        if (message.disconnectReason !== 0)
            writer.tag(1, WireType.Varint).uint32(message.disconnectReason);
        /* Ciot.TcpStatus tcp = 2; */
        if (message.tcp)
            TcpStatus.internalBinaryWrite(message.tcp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiScanState scan_state = 3; */
        if (message.scanState !== 0)
            writer.tag(3, WireType.Varint).int32(message.scanState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiStatus
 */
export const WifiStatus = new WifiStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiInfo$Type extends MessageType<WifiInfo> {
    constructor() {
        super("Ciot.WifiInfo", [
            { no: 1, name: "tcp", kind: "message", T: () => TcpInfo },
            { no: 2, name: "ap", kind: "message", T: () => WifiApInfo }
        ]);
    }
    create(value?: PartialMessage<WifiInfo>): WifiInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WifiInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiInfo): WifiInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.TcpInfo tcp */ 1:
                    message.tcp = TcpInfo.internalBinaryRead(reader, reader.uint32(), options, message.tcp);
                    break;
                case /* Ciot.WifiApInfo ap */ 2:
                    message.ap = WifiApInfo.internalBinaryRead(reader, reader.uint32(), options, message.ap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.TcpInfo tcp = 1; */
        if (message.tcp)
            TcpInfo.internalBinaryWrite(message.tcp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiApInfo ap = 2; */
        if (message.ap)
            WifiApInfo.internalBinaryWrite(message.ap, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiInfo
 */
export const WifiInfo = new WifiInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiReqScan$Type extends MessageType<WifiReqScan> {
    constructor() {
        super("Ciot.WifiReqScan", []);
    }
    create(value?: PartialMessage<WifiReqScan>): WifiReqScan {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WifiReqScan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiReqScan): WifiReqScan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiReqScan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiReqScan
 */
export const WifiReqScan = new WifiReqScan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiReqScanResult$Type extends MessageType<WifiReqScanResult> {
    constructor() {
        super("Ciot.WifiReqScanResult", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WifiReqScanResult>): WifiReqScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial<WifiReqScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiReqScanResult): WifiReqScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiReqScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiReqScanResult
 */
export const WifiReqScanResult = new WifiReqScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiReqGetAp$Type extends MessageType<WifiReqGetAp> {
    constructor() {
        super("Ciot.WifiReqGetAp", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WifiReqGetAp>): WifiReqGetAp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<WifiReqGetAp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiReqGetAp): WifiReqGetAp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiReqGetAp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiReqGetAp
 */
export const WifiReqGetAp = new WifiReqGetAp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiReq$Type extends MessageType<WifiReq> {
    constructor() {
        super("Ciot.WifiReq", [
            { no: 1, name: "scan", kind: "message", oneof: "type", T: () => WifiReqScan },
            { no: 2, name: "get_ap", kind: "message", oneof: "type", T: () => WifiReqGetAp }
        ]);
    }
    create(value?: PartialMessage<WifiReq>): WifiReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<WifiReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiReq): WifiReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.WifiReqScan scan */ 1:
                    message.type = {
                        oneofKind: "scan",
                        scan: WifiReqScan.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).scan)
                    };
                    break;
                case /* Ciot.WifiReqGetAp get_ap */ 2:
                    message.type = {
                        oneofKind: "getAp",
                        getAp: WifiReqGetAp.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).getAp)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.WifiReqScan scan = 1; */
        if (message.type.oneofKind === "scan")
            WifiReqScan.internalBinaryWrite(message.type.scan, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiReqGetAp get_ap = 2; */
        if (message.type.oneofKind === "getAp")
            WifiReqGetAp.internalBinaryWrite(message.type.getAp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiReq
 */
export const WifiReq = new WifiReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiResp$Type extends MessageType<WifiResp> {
    constructor() {
        super("Ciot.WifiResp", [
            { no: 1, name: "scan", kind: "message", oneof: "type", T: () => WifiReqScanResult },
            { no: 2, name: "get_ap", kind: "message", oneof: "type", T: () => WifiApInfo }
        ]);
    }
    create(value?: PartialMessage<WifiResp>): WifiResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<WifiResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiResp): WifiResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.WifiReqScanResult scan */ 1:
                    message.type = {
                        oneofKind: "scan",
                        scan: WifiReqScanResult.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).scan)
                    };
                    break;
                case /* Ciot.WifiApInfo get_ap */ 2:
                    message.type = {
                        oneofKind: "getAp",
                        getAp: WifiApInfo.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).getAp)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.WifiReqScanResult scan = 1; */
        if (message.type.oneofKind === "scan")
            WifiReqScanResult.internalBinaryWrite(message.type.scan, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiApInfo get_ap = 2; */
        if (message.type.oneofKind === "getAp")
            WifiApInfo.internalBinaryWrite(message.type.getAp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiResp
 */
export const WifiResp = new WifiResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiData$Type extends MessageType<WifiData> {
    constructor() {
        super("Ciot.WifiData", [
            { no: 1, name: "stop", kind: "message", oneof: "type", T: () => WifiStop },
            { no: 2, name: "config", kind: "message", oneof: "type", T: () => WifiCfg },
            { no: 3, name: "status", kind: "message", oneof: "type", T: () => WifiStatus },
            { no: 4, name: "request", kind: "message", oneof: "type", T: () => WifiReq },
            { no: 5, name: "response", kind: "message", oneof: "type", T: () => WifiResp },
            { no: 6, name: "info", kind: "message", oneof: "type", T: () => WifiInfo }
        ]);
    }
    create(value?: PartialMessage<WifiData>): WifiData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<WifiData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiData): WifiData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.WifiStop stop */ 1:
                    message.type = {
                        oneofKind: "stop",
                        stop: WifiStop.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).stop)
                    };
                    break;
                case /* Ciot.WifiCfg config */ 2:
                    message.type = {
                        oneofKind: "config",
                        config: WifiCfg.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).config)
                    };
                    break;
                case /* Ciot.WifiStatus status */ 3:
                    message.type = {
                        oneofKind: "status",
                        status: WifiStatus.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).status)
                    };
                    break;
                case /* Ciot.WifiReq request */ 4:
                    message.type = {
                        oneofKind: "request",
                        request: WifiReq.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).request)
                    };
                    break;
                case /* Ciot.WifiResp response */ 5:
                    message.type = {
                        oneofKind: "response",
                        response: WifiResp.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).response)
                    };
                    break;
                case /* Ciot.WifiInfo info */ 6:
                    message.type = {
                        oneofKind: "info",
                        info: WifiInfo.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).info)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.WifiStop stop = 1; */
        if (message.type.oneofKind === "stop")
            WifiStop.internalBinaryWrite(message.type.stop, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiCfg config = 2; */
        if (message.type.oneofKind === "config")
            WifiCfg.internalBinaryWrite(message.type.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiStatus status = 3; */
        if (message.type.oneofKind === "status")
            WifiStatus.internalBinaryWrite(message.type.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiReq request = 4; */
        if (message.type.oneofKind === "request")
            WifiReq.internalBinaryWrite(message.type.request, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiResp response = 5; */
        if (message.type.oneofKind === "response")
            WifiResp.internalBinaryWrite(message.type.response, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiInfo info = 6; */
        if (message.type.oneofKind === "info")
            WifiInfo.internalBinaryWrite(message.type.info, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.WifiData
 */
export const WifiData = new WifiData$Type();
