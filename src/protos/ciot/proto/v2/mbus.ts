// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "ciot/proto/v2/mbus.proto" (package "Ciot", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Message representing a Modbus function request
 *
 * @generated from protobuf message Ciot.MbusFunctionReq
 */
export interface MbusFunctionReq {
    /**
     * @generated from protobuf field: Ciot.MbusFuncCode code = 1
     */
    code: MbusFuncCode; // Modbus function code
    /**
     * @generated from protobuf field: uint32 address = 2
     */
    address: number; // Register/coil start address
    /**
     * @generated from protobuf field: repeated uint32 data = 3
     */
    data: number[]; // Optional written values. 
    /**
     * @generated from protobuf field: uint32 read_count = 4
     */
    readCount: number; // Optional values count to read
    /**
     * @generated from protobuf field: uint32 max_attempts = 5
     */
    maxAttempts: number; // Max attempts
    /**
     * @generated from protobuf field: uint32 error = 6
     */
    error: number; // Error code
}
/**
 * Enum representing Modbus client error codes.
 *
 * @generated from protobuf enum Ciot.MbusError
 */
export enum MbusError {
    /**
     * No error
     *
     * @generated from protobuf enum value: MBUS_ERROR_NONE = 0;
     */
    NONE = 0,
    /**
     * Invalid register address
     *
     * @generated from protobuf enum value: MBUS_ERROR_REG_ADDR = 1;
     */
    REG_ADDR = 1,
    /**
     * Invalid argument
     *
     * @generated from protobuf enum value: MBUS_ERROR_ARG = 2;
     */
    ARG = 2,
    /**
     * Port layer error
     *
     * @generated from protobuf enum value: MBUS_ERROR_PORT_LAYER = 3;
     */
    PORT_LAYER = 3,
    /**
     * No resource error
     *
     * @generated from protobuf enum value: MBUS_ERROR_NO_RESOURCE = 4;
     */
    NO_RESOURCE = 4,
    /**
     * I/O error
     *
     * @generated from protobuf enum value: MBUS_ERROR_IO = 5;
     */
    IO = 5,
    /**
     * Protocol stack invalid state error
     *
     * @generated from protobuf enum value: MBUS_ERROR_STATE = 6;
     */
    STATE = 6,
    /**
     * Timeout error
     *
     * @generated from protobuf enum value: MBUS_ERROR_TIMEOUT = 7;
     */
    TIMEOUT = 7
}
/**
 * Enum representing Modbus function codes
 *
 * @generated from protobuf enum Ciot.MbusFuncCode
 */
export enum MbusFuncCode {
    /**
     * No function
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_NONE = 0;
     */
    NONE = 0,
    /**
     * Read Coils (0x01)
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_READ_COILS = 1;
     */
    READ_COILS = 1,
    /**
     * Read Discrete Inputs (0x02)
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_READ_DI = 2;
     */
    READ_DI = 2,
    /**
     * Read Holding Registers (0x03)
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_READ_HR = 3;
     */
    READ_HR = 3,
    /**
     * Read Input Registers (0x04)
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_READ_IR = 4;
     */
    READ_IR = 4,
    /**
     * Write Single Coil (0x05)
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_WRITE_SINGLE_COIL = 5;
     */
    WRITE_SINGLE_COIL = 5,
    /**
     * Write Single Holding Register (0x06)
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_WRITE_SINGLE_HR = 6;
     */
    WRITE_SINGLE_HR = 6,
    /**
     * Write Coils (0x0F)
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_WRITE_MULTIPLE_COILS = 15;
     */
    WRITE_MULTIPLE_COILS = 15,
    /**
     * Write Holding Registers (0x10)
     *
     * @generated from protobuf enum value: MBUS_FUNC_CODE_WRITE_MULTIPLE_HR = 16;
     */
    WRITE_MULTIPLE_HR = 16
}
// @generated message type with reflection information, may provide speed optimized methods
class MbusFunctionReq$Type extends MessageType<MbusFunctionReq> {
    constructor() {
        super("Ciot.MbusFunctionReq", [
            { no: 1, name: "code", kind: "enum", T: () => ["Ciot.MbusFuncCode", MbusFuncCode, "MBUS_FUNC_CODE_"] },
            { no: 2, name: "address", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "read_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "max_attempts", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "error", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MbusFunctionReq>): MbusFunctionReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.address = 0;
        message.data = [];
        message.readCount = 0;
        message.maxAttempts = 0;
        message.error = 0;
        if (value !== undefined)
            reflectionMergePartial<MbusFunctionReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MbusFunctionReq): MbusFunctionReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.MbusFuncCode code */ 1:
                    message.code = reader.int32();
                    break;
                case /* uint32 address */ 2:
                    message.address = reader.uint32();
                    break;
                case /* repeated uint32 data */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.data.push(reader.uint32());
                    else
                        message.data.push(reader.uint32());
                    break;
                case /* uint32 read_count */ 4:
                    message.readCount = reader.uint32();
                    break;
                case /* uint32 max_attempts */ 5:
                    message.maxAttempts = reader.uint32();
                    break;
                case /* uint32 error */ 6:
                    message.error = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MbusFunctionReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.MbusFuncCode code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* uint32 address = 2; */
        if (message.address !== 0)
            writer.tag(2, WireType.Varint).uint32(message.address);
        /* repeated uint32 data = 3; */
        if (message.data.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.data.length; i++)
                writer.uint32(message.data[i]);
            writer.join();
        }
        /* uint32 read_count = 4; */
        if (message.readCount !== 0)
            writer.tag(4, WireType.Varint).uint32(message.readCount);
        /* uint32 max_attempts = 5; */
        if (message.maxAttempts !== 0)
            writer.tag(5, WireType.Varint).uint32(message.maxAttempts);
        /* uint32 error = 6; */
        if (message.error !== 0)
            writer.tag(6, WireType.Varint).uint32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.MbusFunctionReq
 */
export const MbusFunctionReq = new MbusFunctionReq$Type();
