// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "ciot/proto/v2/uart.proto" (package "Ciot", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Message used to stop uart interface
 *
 * @generated from protobuf message Ciot.UartStop
 */
export interface UartStop {
}
/**
 * @generated from protobuf message Ciot.UartGpioCfg
 */
export interface UartGpioCfg {
    /**
     * @generated from protobuf field: sint32 rx = 1
     */
    rx: number; // RX pin number.
    /**
     * @generated from protobuf field: sint32 tx = 2
     */
    tx: number; // TX pin number.
    /**
     * @generated from protobuf field: sint32 rts = 3
     */
    rts: number; // RTS pin number.
    /**
     * @generated from protobuf field: sint32 cts = 4
     */
    cts: number; // CTS pin number.
}
/**
 * Message representing configuration for the UART module.
 *
 * @generated from protobuf message Ciot.UartCfg
 */
export interface UartCfg {
    /**
     * @generated from protobuf field: uint32 baud_rate = 1
     */
    baudRate: number; // Baud rate for UART.
    /**
     * @generated from protobuf field: uint32 num = 2
     */
    num: number; // UART number.
    /**
     * @generated from protobuf field: Ciot.UartGpioCfg gpio = 3
     */
    gpio?: UartGpioCfg; // GPIO configuration for UART.
    /**
     * @generated from protobuf field: uint32 parity = 4
     */
    parity: number; // Parity for UART.
    /**
     * @generated from protobuf field: bool flow_control = 5
     */
    flowControl: boolean; // Flow control for UART.
    /**
     * @generated from protobuf field: bool dtr = 6
     */
    dtr: boolean; // DTR (Data Terminal Ready) signal.
    /**
     * @generated from protobuf field: uint32 mode = 7
     */
    mode: number; // UART mode (used to enable rs485 mode on some mcus).
    /**
     * @generated from protobuf field: uint32 read_timeout = 8
     */
    readTimeout: number; // UART read timeout
    /**
     * @generated from protobuf field: uint32 write_timeout = 9
     */
    writeTimeout: number; // UART write timeout
}
/**
 * Message representing status for the UART module.
 *
 * @generated from protobuf message Ciot.UartStatus
 */
export interface UartStatus {
    /**
     * @generated from protobuf field: Ciot.UartState state = 1
     */
    state: UartState; // State of the UART module.
    /**
     * @generated from protobuf field: Ciot.UartError error = 2
     */
    error: UartError; // Error encountered by the UART module.
}
/**
 * Message representing a UART request.
 *
 * @generated from protobuf message Ciot.UartReq
 */
export interface UartReq {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "sendData";
        /**
         * @generated from protobuf field: bytes send_data = 1
         */
        sendData: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Message representing data for the UART interface.
 *
 * @generated from protobuf message Ciot.UartData
 */
export interface UartData {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "stop";
        /**
         * @generated from protobuf field: Ciot.UartStop stop = 1
         */
        stop: UartStop; // Stop UART interface.
    } | {
        oneofKind: "config";
        /**
         * @generated from protobuf field: Ciot.UartCfg config = 2
         */
        config: UartCfg; // Configuration for the UART interface.
    } | {
        oneofKind: "status";
        /**
         * @generated from protobuf field: Ciot.UartStatus status = 3
         */
        status: UartStatus; // Status of the UART interface.
    } | {
        oneofKind: "request";
        /**
         * @generated from protobuf field: Ciot.UartReq request = 4
         */
        request: UartReq; // UART request data.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Enum representing the state of the UART module.
 *
 * @generated from protobuf enum Ciot.UartState
 */
export enum UartState {
    /**
     * UART is closed.
     *
     * @generated from protobuf enum value: UART_STATE_CLOSED = 0;
     */
    CLOSED = 0,
    /**
     * UART is started.
     *
     * @generated from protobuf enum value: UART_STATE_STARTED = 1;
     */
    STARTED = 1,
    /**
     * UART encountered an internal error.
     *
     * @generated from protobuf enum value: UART_STATE_INTERNAL_ERROR = 2;
     */
    INTERNAL_ERROR = 2,
    /**
     * UART encountered a CIOT-S (Custom IoT System) error.
     *
     * @generated from protobuf enum value: UART_STATE_CIOT_S_ERROR = 3;
     */
    CIOT_S_ERROR = 3
}
/**
 * Enum representing different types of UART requests.
 *
 * @generated from protobuf enum Ciot.UartReqType
 */
export enum UartReqType {
    /**
     * Unknown UART request type.
     *
     * @generated from protobuf enum value: UART_REQ_TYPE_UNKOWN = 0;
     */
    UNKOWN = 0,
    /**
     * Request to send data via UART.
     *
     * @generated from protobuf enum value: UART_REQ_TYPE_SEND_DATA = 1;
     */
    SEND_DATA = 1,
    /**
     * Request to send bytes via UART.
     *
     * @generated from protobuf enum value: UART_REQ_TYPE_SEND_BYTES = 2;
     */
    SEND_BYTES = 2
}
/**
 * Enum representing different UART error types.
 *
 * @generated from protobuf enum Ciot.UartError
 */
export enum UartError {
    /**
     * No UART error.
     *
     * @generated from protobuf enum value: UART_ERROR_NONE = 0;
     */
    NONE = 0,
    /**
     * UART break error.
     *
     * @generated from protobuf enum value: UART_ERROR_BREAK = 1;
     */
    BREAK = 1,
    /**
     * UART buffer full error.
     *
     * @generated from protobuf enum value: UART_ERROR_BUFFER_FULL = 2;
     */
    BUFFER_FULL = 2,
    /**
     * UART FIFO overflow error.
     *
     * @generated from protobuf enum value: UART_ERROR_FIFO_OVERFLOW = 3;
     */
    FIFO_OVERFLOW = 3,
    /**
     * UART frame error.
     *
     * @generated from protobuf enum value: UART_ERROR_FRAME = 4;
     */
    FRAME = 4,
    /**
     * UART parity error.
     *
     * @generated from protobuf enum value: UART_ERROR_PARITY = 5;
     */
    PARITY = 5,
    /**
     * UART data break error.
     *
     * @generated from protobuf enum value: UART_ERROR_DATA_BREAK = 6;
     */
    DATA_BREAK = 6,
    /**
     * UART open error.
     *
     * @generated from protobuf enum value: UART_ERROR_OPEN = 8;
     */
    OPEN = 8,
    /**
     * Unknown UART event error.
     *
     * @generated from protobuf enum value: UART_ERROR_UNKNOWN = 9;
     */
    UNKNOWN = 9
}
// @generated message type with reflection information, may provide speed optimized methods
class UartStop$Type extends MessageType<UartStop> {
    constructor() {
        super("Ciot.UartStop", []);
    }
    create(value?: PartialMessage<UartStop>): UartStop {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UartStop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UartStop): UartStop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UartStop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.UartStop
 */
export const UartStop = new UartStop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UartGpioCfg$Type extends MessageType<UartGpioCfg> {
    constructor() {
        super("Ciot.UartGpioCfg", [
            { no: 1, name: "rx", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "tx", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "rts", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "cts", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UartGpioCfg>): UartGpioCfg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rx = 0;
        message.tx = 0;
        message.rts = 0;
        message.cts = 0;
        if (value !== undefined)
            reflectionMergePartial<UartGpioCfg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UartGpioCfg): UartGpioCfg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 rx */ 1:
                    message.rx = reader.sint32();
                    break;
                case /* sint32 tx */ 2:
                    message.tx = reader.sint32();
                    break;
                case /* sint32 rts */ 3:
                    message.rts = reader.sint32();
                    break;
                case /* sint32 cts */ 4:
                    message.cts = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UartGpioCfg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 rx = 1; */
        if (message.rx !== 0)
            writer.tag(1, WireType.Varint).sint32(message.rx);
        /* sint32 tx = 2; */
        if (message.tx !== 0)
            writer.tag(2, WireType.Varint).sint32(message.tx);
        /* sint32 rts = 3; */
        if (message.rts !== 0)
            writer.tag(3, WireType.Varint).sint32(message.rts);
        /* sint32 cts = 4; */
        if (message.cts !== 0)
            writer.tag(4, WireType.Varint).sint32(message.cts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.UartGpioCfg
 */
export const UartGpioCfg = new UartGpioCfg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UartCfg$Type extends MessageType<UartCfg> {
    constructor() {
        super("Ciot.UartCfg", [
            { no: 1, name: "baud_rate", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "gpio", kind: "message", T: () => UartGpioCfg },
            { no: 4, name: "parity", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "flow_control", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "dtr", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "mode", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "read_timeout", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "write_timeout", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UartCfg>): UartCfg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.baudRate = 0;
        message.num = 0;
        message.parity = 0;
        message.flowControl = false;
        message.dtr = false;
        message.mode = 0;
        message.readTimeout = 0;
        message.writeTimeout = 0;
        if (value !== undefined)
            reflectionMergePartial<UartCfg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UartCfg): UartCfg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 baud_rate */ 1:
                    message.baudRate = reader.uint32();
                    break;
                case /* uint32 num */ 2:
                    message.num = reader.uint32();
                    break;
                case /* Ciot.UartGpioCfg gpio */ 3:
                    message.gpio = UartGpioCfg.internalBinaryRead(reader, reader.uint32(), options, message.gpio);
                    break;
                case /* uint32 parity */ 4:
                    message.parity = reader.uint32();
                    break;
                case /* bool flow_control */ 5:
                    message.flowControl = reader.bool();
                    break;
                case /* bool dtr */ 6:
                    message.dtr = reader.bool();
                    break;
                case /* uint32 mode */ 7:
                    message.mode = reader.uint32();
                    break;
                case /* uint32 read_timeout */ 8:
                    message.readTimeout = reader.uint32();
                    break;
                case /* uint32 write_timeout */ 9:
                    message.writeTimeout = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UartCfg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 baud_rate = 1; */
        if (message.baudRate !== 0)
            writer.tag(1, WireType.Varint).uint32(message.baudRate);
        /* uint32 num = 2; */
        if (message.num !== 0)
            writer.tag(2, WireType.Varint).uint32(message.num);
        /* Ciot.UartGpioCfg gpio = 3; */
        if (message.gpio)
            UartGpioCfg.internalBinaryWrite(message.gpio, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 parity = 4; */
        if (message.parity !== 0)
            writer.tag(4, WireType.Varint).uint32(message.parity);
        /* bool flow_control = 5; */
        if (message.flowControl !== false)
            writer.tag(5, WireType.Varint).bool(message.flowControl);
        /* bool dtr = 6; */
        if (message.dtr !== false)
            writer.tag(6, WireType.Varint).bool(message.dtr);
        /* uint32 mode = 7; */
        if (message.mode !== 0)
            writer.tag(7, WireType.Varint).uint32(message.mode);
        /* uint32 read_timeout = 8; */
        if (message.readTimeout !== 0)
            writer.tag(8, WireType.Varint).uint32(message.readTimeout);
        /* uint32 write_timeout = 9; */
        if (message.writeTimeout !== 0)
            writer.tag(9, WireType.Varint).uint32(message.writeTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.UartCfg
 */
export const UartCfg = new UartCfg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UartStatus$Type extends MessageType<UartStatus> {
    constructor() {
        super("Ciot.UartStatus", [
            { no: 1, name: "state", kind: "enum", T: () => ["Ciot.UartState", UartState, "UART_STATE_"] },
            { no: 2, name: "error", kind: "enum", T: () => ["Ciot.UartError", UartError, "UART_ERROR_"] }
        ]);
    }
    create(value?: PartialMessage<UartStatus>): UartStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        message.error = 0;
        if (value !== undefined)
            reflectionMergePartial<UartStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UartStatus): UartStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.UartState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* Ciot.UartError error */ 2:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UartStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.UartState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* Ciot.UartError error = 2; */
        if (message.error !== 0)
            writer.tag(2, WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.UartStatus
 */
export const UartStatus = new UartStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UartReq$Type extends MessageType<UartReq> {
    constructor() {
        super("Ciot.UartReq", [
            { no: 1, name: "send_data", kind: "scalar", oneof: "type", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UartReq>): UartReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<UartReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UartReq): UartReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes send_data */ 1:
                    message.type = {
                        oneofKind: "sendData",
                        sendData: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UartReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes send_data = 1; */
        if (message.type.oneofKind === "sendData")
            writer.tag(1, WireType.LengthDelimited).bytes(message.type.sendData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.UartReq
 */
export const UartReq = new UartReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UartData$Type extends MessageType<UartData> {
    constructor() {
        super("Ciot.UartData", [
            { no: 1, name: "stop", kind: "message", oneof: "type", T: () => UartStop },
            { no: 2, name: "config", kind: "message", oneof: "type", T: () => UartCfg },
            { no: 3, name: "status", kind: "message", oneof: "type", T: () => UartStatus },
            { no: 4, name: "request", kind: "message", oneof: "type", T: () => UartReq }
        ]);
    }
    create(value?: PartialMessage<UartData>): UartData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<UartData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UartData): UartData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.UartStop stop */ 1:
                    message.type = {
                        oneofKind: "stop",
                        stop: UartStop.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).stop)
                    };
                    break;
                case /* Ciot.UartCfg config */ 2:
                    message.type = {
                        oneofKind: "config",
                        config: UartCfg.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).config)
                    };
                    break;
                case /* Ciot.UartStatus status */ 3:
                    message.type = {
                        oneofKind: "status",
                        status: UartStatus.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).status)
                    };
                    break;
                case /* Ciot.UartReq request */ 4:
                    message.type = {
                        oneofKind: "request",
                        request: UartReq.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).request)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UartData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.UartStop stop = 1; */
        if (message.type.oneofKind === "stop")
            UartStop.internalBinaryWrite(message.type.stop, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.UartCfg config = 2; */
        if (message.type.oneofKind === "config")
            UartCfg.internalBinaryWrite(message.type.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.UartStatus status = 3; */
        if (message.type.oneofKind === "status")
            UartStatus.internalBinaryWrite(message.type.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.UartReq request = 4; */
        if (message.type.oneofKind === "request")
            UartReq.internalBinaryWrite(message.type.request, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.UartData
 */
export const UartData = new UartData$Type();
