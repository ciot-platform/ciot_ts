// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "ciot/proto/v2/gpio.proto" (package "Ciot", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Gpio stop message
 *
 * @generated from protobuf message Ciot.GpioStop
 */
export interface GpioStop {
    /**
     * @generated from protobuf field: Ciot.GpioCfg cfg = 1
     */
    cfg?: GpioCfg; // Config of gpio to be stopped
}
/**
 * Gpio pin configuration
 *
 * @generated from protobuf message Ciot.GpioPinCfg
 */
export interface GpioPinCfg {
    /**
     * @generated from protobuf field: uint32 num = 1
     */
    num: number; // Gpio pin number
    /**
     * @generated from protobuf field: Ciot.GpioMode mode = 2
     */
    mode: GpioMode; // Gpio mode
    /**
     * @generated from protobuf field: Ciot.GpioPull pull = 3
     */
    pull: GpioPull; // Gpio pullup/pulldown configuration
}
/**
 * Message representing gpio configuration
 *
 * @generated from protobuf message Ciot.GpioCfg
 */
export interface GpioCfg {
    /**
     * @generated from protobuf field: repeated Ciot.GpioPinCfg pins = 1
     */
    pins: GpioPinCfg[]; // Pins list configuration
    /**
     * @generated from protobuf field: uint32 blink_interval = 2
     */
    blinkInterval: number; // Interval between gpio blinks in miliseconds
}
/**
 * Message used to read/set all gpio states
 *
 * @generated from protobuf message Ciot.GpioStatus
 */
export interface GpioStatus {
    /**
     * @generated from protobuf field: bytes states = 1
     */
    states: Uint8Array; // Gpio states list
}
/**
 * Message used to set/read signle gpio state info
 *
 * @generated from protobuf message Ciot.GpioStateInfo
 */
export interface GpioStateInfo {
    /**
     * @generated from protobuf field: uint32 num = 1
     */
    num: number; // Gpio num
    /**
     * @generated from protobuf field: Ciot.GpioState state = 2
     */
    state: GpioState; // Gpio state
}
/**
 * Message representing an gpio request
 *
 * @generated from protobuf message Ciot.GpioReq
 */
export interface GpioReq {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "setStatus";
        /**
         * @generated from protobuf field: Ciot.GpioStatus set_status = 1
         */
        setStatus: GpioStatus; // Set Status request.
    } | {
        oneofKind: "setState";
        /**
         * @generated from protobuf field: Ciot.GpioStateInfo set_state = 2
         */
        setState: GpioStateInfo; // Set sate request
    } | {
        oneofKind: undefined;
    };
}
/**
 * Message representing gpio data
 *
 * @generated from protobuf message Ciot.GpioData
 */
export interface GpioData {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "stop";
        /**
         * @generated from protobuf field: Ciot.GpioStop stop = 1
         */
        stop: GpioStop; // Stop gpio
    } | {
        oneofKind: "config";
        /**
         * @generated from protobuf field: Ciot.GpioCfg config = 2
         */
        config: GpioCfg; // Configuration data
    } | {
        oneofKind: "status";
        /**
         * @generated from protobuf field: Ciot.GpioStatus status = 3
         */
        status: GpioStatus; // Status data
    } | {
        oneofKind: "request";
        /**
         * @generated from protobuf field: Ciot.GpioReq request = 4
         */
        request: GpioReq; // Request data
    } | {
        oneofKind: undefined;
    };
}
/**
 * Enum representing the state of gpio
 *
 * @generated from protobuf enum Ciot.GpioState
 */
export enum GpioState {
    /**
     * Gpio is low
     *
     * @generated from protobuf enum value: GPIO_STATE_LOW = 0;
     */
    LOW = 0,
    /**
     * Gpio is high
     *
     * @generated from protobuf enum value: GPIO_STATE_HIGH = 1;
     */
    HIGH = 1,
    /**
     * Gpio is alternating it state once
     *
     * @generated from protobuf enum value: GPIO_STATE_BLINK = 2;
     */
    BLINK = 2,
    /**
     * Gpio alternated it state once
     *
     * @generated from protobuf enum value: GPIO_STATE_BLINKED = 3;
     */
    BLINKED = 3,
    /**
     * Gpio is alternating it state
     *
     * @generated from protobuf enum value: GPIO_STATE_BLINKING = 4;
     */
    BLINKING = 4,
    /**
     * Gpio is in error
     *
     * @generated from protobuf enum value: GPIO_STATE_ERROR = 5;
     */
    ERROR = 5
}
/**
 * Enum representing gpio modes
 *
 * @generated from protobuf enum Ciot.GpioMode
 */
export enum GpioMode {
    /**
     * Disable gpio
     *
     * @generated from protobuf enum value: GPIO_MODE_DISABLED = 0;
     */
    DISABLED = 0,
    /**
     * Enable gpio input mode
     *
     * @generated from protobuf enum value: GPIO_MODE_INPUT = 1;
     */
    INPUT = 1,
    /**
     * Enable gpio output mode
     *
     * @generated from protobuf enum value: GPIO_MODE_OUTPUT = 2;
     */
    OUTPUT = 2
}
/**
 * Enum representing gpio internal pullup/pulldown modes
 *
 * @generated from protobuf enum Ciot.GpioPull
 */
export enum GpioPull {
    /**
     * Disable gpio internal pullup/pulldown
     *
     * @generated from protobuf enum value: GPIO_PULL_DISABLED = 0;
     */
    DISABLED = 0,
    /**
     * Enable gpio internal pullup
     *
     * @generated from protobuf enum value: GPIO_PULL_UP = 1;
     */
    UP = 1,
    /**
     * Enable gpio internal pulldown
     *
     * @generated from protobuf enum value: GPIO_PULL_DOWN = 2;
     */
    DOWN = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class GpioStop$Type extends MessageType<GpioStop> {
    constructor() {
        super("Ciot.GpioStop", [
            { no: 1, name: "cfg", kind: "message", T: () => GpioCfg }
        ]);
    }
    create(value?: PartialMessage<GpioStop>): GpioStop {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GpioStop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpioStop): GpioStop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.GpioCfg cfg */ 1:
                    message.cfg = GpioCfg.internalBinaryRead(reader, reader.uint32(), options, message.cfg);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpioStop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.GpioCfg cfg = 1; */
        if (message.cfg)
            GpioCfg.internalBinaryWrite(message.cfg, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.GpioStop
 */
export const GpioStop = new GpioStop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpioPinCfg$Type extends MessageType<GpioPinCfg> {
    constructor() {
        super("Ciot.GpioPinCfg", [
            { no: 1, name: "num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "mode", kind: "enum", T: () => ["Ciot.GpioMode", GpioMode, "GPIO_MODE_"] },
            { no: 3, name: "pull", kind: "enum", T: () => ["Ciot.GpioPull", GpioPull, "GPIO_PULL_"] }
        ]);
    }
    create(value?: PartialMessage<GpioPinCfg>): GpioPinCfg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.num = 0;
        message.mode = 0;
        message.pull = 0;
        if (value !== undefined)
            reflectionMergePartial<GpioPinCfg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpioPinCfg): GpioPinCfg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 num */ 1:
                    message.num = reader.uint32();
                    break;
                case /* Ciot.GpioMode mode */ 2:
                    message.mode = reader.int32();
                    break;
                case /* Ciot.GpioPull pull */ 3:
                    message.pull = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpioPinCfg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 num = 1; */
        if (message.num !== 0)
            writer.tag(1, WireType.Varint).uint32(message.num);
        /* Ciot.GpioMode mode = 2; */
        if (message.mode !== 0)
            writer.tag(2, WireType.Varint).int32(message.mode);
        /* Ciot.GpioPull pull = 3; */
        if (message.pull !== 0)
            writer.tag(3, WireType.Varint).int32(message.pull);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.GpioPinCfg
 */
export const GpioPinCfg = new GpioPinCfg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpioCfg$Type extends MessageType<GpioCfg> {
    constructor() {
        super("Ciot.GpioCfg", [
            { no: 1, name: "pins", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GpioPinCfg },
            { no: 2, name: "blink_interval", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GpioCfg>): GpioCfg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pins = [];
        message.blinkInterval = 0;
        if (value !== undefined)
            reflectionMergePartial<GpioCfg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpioCfg): GpioCfg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Ciot.GpioPinCfg pins */ 1:
                    message.pins.push(GpioPinCfg.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 blink_interval */ 2:
                    message.blinkInterval = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpioCfg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Ciot.GpioPinCfg pins = 1; */
        for (let i = 0; i < message.pins.length; i++)
            GpioPinCfg.internalBinaryWrite(message.pins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 blink_interval = 2; */
        if (message.blinkInterval !== 0)
            writer.tag(2, WireType.Varint).uint32(message.blinkInterval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.GpioCfg
 */
export const GpioCfg = new GpioCfg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpioStatus$Type extends MessageType<GpioStatus> {
    constructor() {
        super("Ciot.GpioStatus", [
            { no: 1, name: "states", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GpioStatus>): GpioStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.states = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<GpioStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpioStatus): GpioStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes states */ 1:
                    message.states = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpioStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes states = 1; */
        if (message.states.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.states);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.GpioStatus
 */
export const GpioStatus = new GpioStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpioStateInfo$Type extends MessageType<GpioStateInfo> {
    constructor() {
        super("Ciot.GpioStateInfo", [
            { no: 1, name: "num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["Ciot.GpioState", GpioState, "GPIO_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<GpioStateInfo>): GpioStateInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.num = 0;
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<GpioStateInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpioStateInfo): GpioStateInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 num */ 1:
                    message.num = reader.uint32();
                    break;
                case /* Ciot.GpioState state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpioStateInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 num = 1; */
        if (message.num !== 0)
            writer.tag(1, WireType.Varint).uint32(message.num);
        /* Ciot.GpioState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.GpioStateInfo
 */
export const GpioStateInfo = new GpioStateInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpioReq$Type extends MessageType<GpioReq> {
    constructor() {
        super("Ciot.GpioReq", [
            { no: 1, name: "set_status", kind: "message", oneof: "type", T: () => GpioStatus },
            { no: 2, name: "set_state", kind: "message", oneof: "type", T: () => GpioStateInfo }
        ]);
    }
    create(value?: PartialMessage<GpioReq>): GpioReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GpioReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpioReq): GpioReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.GpioStatus set_status */ 1:
                    message.type = {
                        oneofKind: "setStatus",
                        setStatus: GpioStatus.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).setStatus)
                    };
                    break;
                case /* Ciot.GpioStateInfo set_state */ 2:
                    message.type = {
                        oneofKind: "setState",
                        setState: GpioStateInfo.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).setState)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpioReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.GpioStatus set_status = 1; */
        if (message.type.oneofKind === "setStatus")
            GpioStatus.internalBinaryWrite(message.type.setStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.GpioStateInfo set_state = 2; */
        if (message.type.oneofKind === "setState")
            GpioStateInfo.internalBinaryWrite(message.type.setState, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.GpioReq
 */
export const GpioReq = new GpioReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpioData$Type extends MessageType<GpioData> {
    constructor() {
        super("Ciot.GpioData", [
            { no: 1, name: "stop", kind: "message", oneof: "type", T: () => GpioStop },
            { no: 2, name: "config", kind: "message", oneof: "type", T: () => GpioCfg },
            { no: 3, name: "status", kind: "message", oneof: "type", T: () => GpioStatus },
            { no: 4, name: "request", kind: "message", oneof: "type", T: () => GpioReq }
        ]);
    }
    create(value?: PartialMessage<GpioData>): GpioData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GpioData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpioData): GpioData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.GpioStop stop */ 1:
                    message.type = {
                        oneofKind: "stop",
                        stop: GpioStop.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).stop)
                    };
                    break;
                case /* Ciot.GpioCfg config */ 2:
                    message.type = {
                        oneofKind: "config",
                        config: GpioCfg.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).config)
                    };
                    break;
                case /* Ciot.GpioStatus status */ 3:
                    message.type = {
                        oneofKind: "status",
                        status: GpioStatus.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).status)
                    };
                    break;
                case /* Ciot.GpioReq request */ 4:
                    message.type = {
                        oneofKind: "request",
                        request: GpioReq.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).request)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpioData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.GpioStop stop = 1; */
        if (message.type.oneofKind === "stop")
            GpioStop.internalBinaryWrite(message.type.stop, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.GpioCfg config = 2; */
        if (message.type.oneofKind === "config")
            GpioCfg.internalBinaryWrite(message.type.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.GpioStatus status = 3; */
        if (message.type.oneofKind === "status")
            GpioStatus.internalBinaryWrite(message.type.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.GpioReq request = 4; */
        if (message.type.oneofKind === "request")
            GpioReq.internalBinaryWrite(message.type.request, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Ciot.GpioData
 */
export const GpioData = new GpioData$Type();
